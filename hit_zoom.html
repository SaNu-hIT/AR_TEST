<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Hit Testing - Reticle with Updates</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link type="text/css" rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
  </head>

  <body>
    <!-- Slider for resizing the model -->
    <input id="resizeSlider" type="range" min="0.1" max="2" step="0.1" value="1" style="position: fixed; bottom: 20px; width: 80%; z-index: 10;" />

    <script type="module">
      import { ARButton } from "https://unpkg.com/three@0.126.0/examples/jsm/webxr/ARButton.js";

      let container;
      let camera, scene, renderer;
      let reticle;
      let controller;
      let loader;
      let model;

      init();
      animate();

      function init() {
        container = document.createElement("div");
        document.body.appendChild(container);
        loader = new THREE.GLTFLoader();
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        container.appendChild(renderer.domElement);

        controller = renderer.xr.getController(0);
        controller.addEventListener("select", onSelect);

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);

        addReticleToScene();

        const button = ARButton.createButton(renderer, {
          requiredFeatures: ["hit-test"]
        });
        document.body.appendChild(button);
        renderer.domElement.style.display = "none";

        window.addEventListener("resize", onWindowResize, false);

        // Add resize functionality
        const resizeSlider = document.getElementById("resizeSlider");
        resizeSlider.addEventListener("input", (event) => {
          const scale = parseFloat(event.target.value);
          if (model) {
            model.scale.set(scale, scale, scale);
          }
        });
      }

      function addReticleToScene() {
        const geometry = new THREE.RingBufferGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
        const material = new THREE.MeshBasicMaterial();

        reticle = new THREE.Mesh(geometry, material);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);
      }

      function onSelect(event) {
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        pointer.set(
          (event.clientX / window.innerWidth) * 2 - 1,
          -(event.clientY / window.innerHeight) * 2 + 1
        );

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
          const intersect = intersects[0];

          if (model) {
            const newModel = model.clone();
            newModel.position.copy(intersect.point);
            scene.add(newModel);
          }
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        renderer.setAnimationLoop(() => {
          updateZoom();
          render();
        });
      }

      let hitTestSource = null;
      let localSpace = null;
      let hitTestSourceInitialized = false;

      async function initializeHitTestSource() {
        const session = renderer.xr.getSession();
        const viewerSpace = await session.requestReferenceSpace("viewer");
        hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
        localSpace = await session.requestReferenceSpace("local");

        hitTestSourceInitialized = true;

        session.addEventListener("end", () => {
          hitTestSourceInitialized = false;
          hitTestSource = null;
        });
      }

      function render(timestamp, frame) {
        if (frame) {
          if (!hitTestSourceInitialized) {
            initializeHitTestSource();
          }

          if (hitTestSourceInitialized) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);

            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const pose = hit.getPose(localSpace);

              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }

          renderer.render(scene, camera);
        }
      }

      function updateZoom() {
        if (model) {
          const distance = camera.position.distanceTo(model.position);

          const minDistance = 0.5;
          const maxDistance = 5;
          const zoomFactor = THREE.MathUtils.mapLinear(
            distance,
            minDistance,
            maxDistance,
            1.5,
            0.8
          );

          camera.zoom = Math.max(0.8, Math.min(1.5, zoomFactor));
          camera.updateProjectionMatrix();
        }
      }

      loader.load(
        "https://raw.githubusercontent.com/SaNu-hIT/AR_TEST/refs/heads/main/coffee_table_round_01_4k.gltf",
        (gltf) => {
          model = gltf.scene;
          model.scale.set(0.2, 0.2, 0.2);
        },
        undefined,
        (error) => {
          console.error("Error loading GLTF model:", error);
        }
      );
    </script>
  </body>
</html>
