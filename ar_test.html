<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>WebXR AR Example</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">

<button id="start-ar" style="position: absolute; top: 10px; left: 10px; z-index: 10; padding: 10px;">
    Start AR
</button>

<script>
let scene, camera, renderer, reticle;
let xrSession = null;
let hitTestSource = null;
let hitTestSourceRequested = false;

function initializeScene() {
    // Scene setup
    scene = new THREE.Scene();

    // Camera setup
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    scene.add(camera);

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Light setup
    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
    scene.add(light);

    // Reticle setup
    const geometry = new THREE.RingGeometry(0.1, 0.15, 32).rotateX(-Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
    reticle = new THREE.Mesh(geometry, material);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    renderer.setAnimationLoop(render);
}

async function startARSession() {
    if (!navigator.xr) {
        alert("WebXR not supported on this browser.");
        return;
    }

    try {
        xrSession = await navigator.xr.requestSession('immersive-ar', { optionalFeatures: ['hit-test'] });
        renderer.xr.setSession(xrSession);

        xrSession.addEventListener('end', () => {
            xrSession = null;
            hitTestSourceRequested = false;
            document.getElementById('start-ar').style.display = 'block';
        });

        const referenceSpace = await xrSession.requestReferenceSpace('local');
        renderer.xr.setReferenceSpace(referenceSpace);

        initializeScene();
        document.getElementById('start-ar').style.display = 'none';
    } catch (err) {
        console.error("Failed to start AR session:", err);
        alert("Could not start AR session.");
    }
}

function render(timestamp, frame) {
    if (frame && xrSession) {
        const referenceSpace = renderer.xr.getReferenceSpace();

        // Request hit-test source if not already requested
        if (!hitTestSourceRequested) {
            xrSession.requestHitTestSource({ space: referenceSpace })
                .then((source) => {
                    hitTestSource = source;
                })
                .catch((err) => console.error("Failed to create hit-test source:", err));
            hitTestSourceRequested = true;
        }

        // Process hit-test results
        if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);

            if (hitTestResults.length > 0) {
                const hit = hitTestResults[0];
                const pose = hit.getPose(referenceSpace);

                if (pose) {
                    reticle.visible = true;
                    reticle.matrix.fromArray(pose.transform.matrix);
                }
            } else {
                reticle.visible = false;
            }
        }
    }

    renderer.render(scene, camera);
}

document.getElementById('start-ar').addEventListener('click', startARSession);
</script>

</body>
</html>
